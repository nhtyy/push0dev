# Introduction

Here I will go over the primitive steps of implenting ECDSA. This does not include any runtime optimizations and lacks much information about modern best practices when implementing cryptographic protocols! You really shouldn't be implementing anything based off this posts if its not for fun! Also in the end I provide a couple well known observations around using this protocol.

# Basics of Elliptic Curve Cryptography (ECC)

Elliptic Curve Cryptography (ECC) is an approach to public-key cryptography based on the algebraic structure of elliptic curves over finite fields. It provides the same level of security as traditional methods like RSA but with significantly shorter key lengths, resulting in better performance and more efficient use of resources. In this section, we'll introduce the basics of elliptic curves and their algebraic structure, as well as the operations that can be performed on them.

An elliptic curve is defined by the following equation over a finite field $$\mathbb{F}$$ with prime order $$p$$: $$y^2 = x^3 + ax + b \mod p$$.

- A finite field is just a set of prime power order with all the usual operations. (add, sub, mul, div)

The points on this curve that satisfy this relation form a group denoted $$E(\mathbb{F_p})$$ with point addition as the group operation.

The points on the curve are of the form $$(x, y)$$, where $$x$$ and $$y$$ are elements of the field $$\mathbb{F}$$. The curve is symmetric with respect to the x-axis over $$\mathbb{R}$$, but in a finte field you can think of ().

There are a few essential properties and operations associated with elliptic curves:

- Point Addition: Given two points $$P$$ and $$Q$$ on the curve, we can define their sum, $$R = P + Q$$, as the point resulting from the intersection of the curve and the line through $$P$$ and $$Q$$. If $$P$$ and $$Q$$ are vertically aligned, their sum is defined as the point at infinity $$\theta$$, which serves as the identity element.

- Scalar Multiplication: Given a point $$P$$ on the curve and an integer $$k$$, scalar multiplication is defined as the repeated addition of the point $$P$$ to itself $$k$$ times: $$kP = P + P + \cdots + P$$ (k times).

- Identity Element: The identity element, denoted as $$\theta$$, is a special point that behaves like the number zero in traditional arithmetic. When adding any point $$P$$ to the identity element, the result is the same point $$P$$: $$P + \theta = P$$.

- Additive Inverse: For any point $$A = (a_1, a_2)$$ on the curve, its additive inverse $$-A$$ is the point that satisfies the equation $$A + (-A) = \theta$$. The additive inverse can be found as $$-A = (a_1, -a_2)$$. In the context of the finite field $$\mathbb{F_p}$$, this means that $$-A = (a_1, p - a_2)$$.

# ECDSA the algorithm

ECDSA has four main functionalites including key generation: signature generation, signature verification, and public key recovery.

- ## Parameters

  - The generator point $$G$$ generates a cyclic subgroup of order $$n$$
  - The elliptic curve has order $$|E(\mathbb{F})| = c$$, which represents the total number of points on the curve, recall subgroup defintion so, $$n|c$$
  - **Typically you want c to be prime** so you dont need to worry about subgroups, there are ways to find curve parameters to do this
  - ECDSA is typically done done over a **prime field** $$\mathbb{F}$$ with order $$P$$, where $$E\mathbb{(F)}$$ denotes the **group of points**, and $$n$$ is the order of the subgroup generated by $$G$$

- ## Key Generation

  1. Choose a generator point $$G$$ from the elliptic curve $$E(\mathbb{F})$$, where $$F$$ is a field with prime order $$P$$
  2. The user selects a secret key $$x \in [1, n-1]$$ and computes the public key $$X = xG$$ using scalar multiplication

- ## Signature Generation

  1. Choose $$k \in [1, n-1]$$ at random
  2. Compute the message hash $$e = H(M)$$, where $$H$$ is a cryptographically secure hash function, and $$M$$ is the message
  3. Compute $$R = (x_R, y_R) = kG$$
  4. Compute $$r = x_R \mod n$$
  5. Calculate $$s = k^{-1}(e + rx)  \mod n$$
  6. The signature is $$\sigma = (r, s)$$

- ## Signature Verification

1. Ensure $$r, s \in \mathbb{Z}_n$$ and $$X \neq \theta$$
2. Calculate $$u_1 = es^{-1}$$ and $$u_2 = rs^{-1}$$
3. Check if $$r_v = r$$, where:
   1. $$R_v = u_1G + u_2X$$
   2. $$R_v = (u_1 + u_2x)G$$
   3. $$R_v = (es^{-1} + s^{-1}rx)G$$
   4. $$R_v = s^{-1}(e + rx)G$$
   5. $$R_v = (k^{-1})^{-1}(e + rx)^{-1}(e + rx)G$$
   6. $$R_v = kG = (x_{R_v}, y_{R_v})$$
   7. $$r_v = x_{R_v} \mod n$$

# Public Key Recovery

The public key recovery process in ECDSA yields multiple results. ecrecover (the evm precompile) uses a recovery id (recid) in its implementation in order to narrow the search for the public key.

- ## Algorithm

  Given a signature $$\sigma = (r, s)$$, the public key recovery algorithm aims to find the public key $$X$$ associated with the signer. This process can generate more than one 'valid results'.

  1. Input: $$\sigma = (r, s)$$
  2. Find all possible $$r'$$ values, where $$x \in \mathbb{Z}, r + xn < p$$
  3. Find the point $$R' = (r', y)$$ by plugging the values into the curve equation
  4. Compute $$X = r^{-1}(sR - eG)$$, where $$e$$ is the message hash

  All values computed are possible signers for the signature and message.

- ## Implementation

  - ### Recovery Id (recid)

    Without a recovery id value, like the one used in Ethereum $$\sigma' = (r, s, v)$$, or further communication, it is only possible to narrow down the possible public keys [(addresses)](https://www.geeksforgeeks.org/how-to-create-an-ethereum-wallet-address-from-a-private-key/#) to a limited number. Additive inverses are easy to find as shown below so recids dont usally cover those.

    This is because $$x_R$$ from signature generation is reduced $$ \mod n$$ which is the order of the generator which divides the order of the curve group $$\mathbb{E(F_p)}$$, BUT $$\mathbb{E(F_p)}$$ is of the form $$(x, y) : x, y \in \mathbb{F_p}$$ and $$n < p$$ at least in secp256k1

    In other words, $$r + n$$ may have been the intended curve point if $$ r + n < p$$, and recids give us a way of informing the consumer that. In general I think the bound is something like $$h + 1 \geq t \geq 1$$ unique points, where $$h$$ is the cofactor of $$n$$ such that $$nh = |E(\mathbb{F})|$$, not including inverses.

  - ### Malleability

    **!! Signatures are malleable and should never be used as identifiers !!** This is because as [derp turkey](https://www.derpturkey.com/inherent-malleability-of-ecdsa-signatures/) shows us, $$(r, s)$$ is a valid signature as well as $$(r, n-s)$$ because $$(e-n)G = (x, p-y)$$
