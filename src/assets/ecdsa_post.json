{
  "post_title": "ECDSA",
  "slug": "ecdsa-evm",
  "sections": [
    {
      "title": "Introduction",
      "content": [
        "Elliptic curve cryptography (ECC) has become a popular choice for secure communication due to its compact key sizes and efficient operations."
      ]
    },
    {
      "title": "Section 1: Elliptic Curve Cryptography (ECC)",
      "content": [
        "Elliptic Curve Cryptography (ECC) is an approach to public-key cryptography based on the algebraic structure of elliptic curves over finite fields. It provides the same level of security as traditional methods like RSA but with significantly shorter key lengths, resulting in better performance and more efficient use of resources. In this section, we'll introduce the basics of elliptic curves and their algebraic structure, as well as the operations that can be performed on them.",
        "An elliptic curve is defined by the following equation over a finite field $$F$$ with prime order $$p$$: $$y^2 = x^3 + ax + b \\mod p$$",
        "The points on this curve that satisfy this relation form a group denoted $$E(\\mathbb{F_p})$$ with point addition as the group operation",
        "The points on the curve are of the form $$(x, y)$$, where $$x$$ and $$y$$ are elements of the field $$\\mathbb{F}$$. The curve is symmetric with respect to the x-axis because $$y^2$$ means that the curve is reflected over the x-axis.",
        "There are a few essential properties and operations associated with elliptic curves:",
        "- Point Addition: Given two points $$P$$ and $$Q$$ on the curve, we can define their sum, $$R = P + Q$$, as the point resulting from the intersection of the curve and the line through $$P$$ and $$Q$$. If $$P$$ and $$Q$$ are vertically aligned, their sum is defined as the point at infinity $$\\theta$$, which serves as the identity element.",
        "- Scalar Multiplication: Given a point $$P$$ on the curve and an integer $$k$$, scalar multiplication is defined as the repeated addition of the point $$P$$ to itself $$k$$ times: $$kP = P + P + \\cdots + P$$ (k times).",
        "- Identity Element: The identity element, denoted as $$\\theta$$, is a special point that behaves like the number zero in traditional arithmetic. When adding any point $$P$$ to the identity element, the result is the same point $$P$$: $$P + \\theta = P$$.",
        "- Additive Inverse: For any point $$A = (a_1, a_2)$$ on the curve, its additive inverse $$-A$$ is the point that satisfies the equation $$A + (-A) = \\theta$$. The additive inverse can be found as $$-A = (a_1, -a_2)$$. In the context of the finite field $$F$$, this means that $$-A = (a_1, p - a_2)$$."
      ]
    },
    {
      "title": "Section 2: Elliptic Curve Digital Signature Algorithm (ECDSA)",
      "content": [
        "In this section, we'll dive into the Elliptic Curve Digital Signature Algorithm (ECDSA) and explore how it works within the context of elliptic curve cryptography. ECDSA is a widely used digital signature algorithm that relies on the algebraic structure of elliptic curves over finite fields.",
        {
          "title": "2.1: ECDSA Basics",
          "content": [
            "ECDSA has four main parts including key generation: signature generation, signature verification, and public key recovery which we'll talk about later",
            {
              "title": "2.2 Key Generation",
              "content": [
                "- Choose a generator point $$G$$ from the elliptic curve $$E(F)$$, where $$F$$ is a field with prime order $$P$$.",
                "- The generator point $$G$$ generates a cyclic subgroup of order $$n$$, denoted by $$|G| = n$$.",
                "- The elliptic curve has order $$|E(F)| = c$$, which represents the total number of points on the curve.",
                "- The user selects a secret key $$x \\in [1, n-1]$$ and computes the public key $$X = xG$$ using scalar multiplication."
              ]
            },
            {
              "title": "2.3 Signature Generation",
              "content": [
                "choose $$k \\in [1, n-1]$$ at random",
                "Compute the message hash $$e = H(M)$$, where $$H$$ is a cryptographically secure hash function, and $$M$$ is the message. Truncate the hash to match the bit length of $$n$$ to avoid collisions when performing modulo operations later on.",
                "Calculate the ephemeral key $$R = (x_R, y_R) = kG$$.",
                "Compute $$r = x_R \\mod n$$.",
                "Calculate $$s = k^{-1}(e + rx)  \\mod n$$",
                "The signature is $$\\sigma = (r, s)$$."
              ]
            },
            {
              "title": "2.4 Signature Verification",
              "content": [
                "- Ensure $$r, s \\in \\mathbb{Z}_n$$ and $$X \\neq \\theta$$.",
                "- Calculate $$u_1 = es^{-1}$$ and $$u_2 = rs^{-1}$$.",
                "- Check if $$r_v = r$$, where:",
                {
                  "title": "",
                  "content": [
                    "- $$R_v = u_1G + u_2X$$",
                    "- $$R_v = (u_1 + u_2x)G$$",
                    "- $$R_v = (es^{-1} + s^{-1}rx)G$$",
                    "- $$R_v = s^{-1}(e + rx)G$$",
                    "- $$R_v = (k^{-1})^{-1}(e + rx)^{-1}(e + rx)G$$",
                    "- $$R_v = kG = (x_{R_v}, y_{R_v})$$",
                    "- $$r_v = x_{R_v} \\mod n$$"
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Section 3: Public Key Recovery in Smart Contracts",
      "content": [
        "The public key recovery process in ECDSA can sometimes yield multiple results. Ethereums uses a recovery id in its implementation in order to correctly identify the public key.",
        {
          "title": "3.1: Public Key Recovery Algorithm",
          "content": [
            "Given a signature $$\\sigma = (r, s)$$, the public key recovery algorithm aims to find the public key $$X$$ associated with the signer. This process can produce 0, 1, or 2 valid results. Here's a step-by-step breakdown of the algorithm:",
            "Input: $$\\sigma = (r, s)$$",
            "Find all possible $$r'$$ values, where $$x \\in \\mathbb{Z}, r + xn < p$$.",
            "Find the point $$R = (r', y)$$ by plugging the values into the curve equation.",
            "Compute $$X = r^{-1}(sR - eG)$$, where $$e$$ is the message hash."
          ]
        },
        "Ethereum smart contracts use the public key recovery feature to efficiently verify transactions without storing the public key in the transaction data. By including a recovery id byte in the signature tuple, Ethereum can identify the correct point to use during the recovery process and quickly narrow down the possible addresses.",
        {
          "title": "3.2: On Implementing the Public Key Recovery Algorithm",
          "content": [
            "Without a recovery id value, like the one used in Ethereum's $$\\sigma' = (r, s, v)$$, or further communication, it is only possible to narrow down the possible addresses to a limited number. To recover $$R$$, you can plug $$r$$ from the signature into the curve equation. Keep in mind the following:",
            "$$r$$ is the x-coordinate of $$x_R \\in (x_R, y_R) = kG \\mod n$$ from the signature generation.",
            "There's a chance the actual $$x_R > n$$ because the x-coordinates come from $$\\mathbb{F}$$ and $$p > n$$. Implementations use custom recid values to identify which point they're using.",
            "In general, you need to compute $$h + 1 \\geq t \\geq 1$$ unique points, not including a points additive inverse, on the curve if you don't have a recid.",
            "When recovering the public key, you need to search for the point whose x-coordinate reduces to $$r \\mod n$$ and is in the proper subgroup with $$G$$. In cases where $$|E(\\mathbb{F})|$$ is prime (like secp256k1), every point on the curve is a generator, as a consecquence of [Lagrange Theorem](https://math.stackexchange.com/questions/267279/proof-of-lagrange-theorem-order-of-a-subgroup-divides-order-of-the-group)"
          ]
        }
      ]
    },
    {
      "title": "Section 4: ECDSA Malleability",
      "content": [
        "ECDSA signatures are called malleable because its possible to modify a given signature in order to achieve potentially unexpected results.",
        {
          "title": "4.1: Malleability of ECDSA Signatures",
          "content": [
            "ECDSA signatures are malleable, meaning that for a given message $$M$$ and public key $$X$$, it is possible to find a second valid signature that can be verified. This property can lead to security issues if not properly addressed. Here are some key points to consider:",
            "You can find a second valid signature $$\\sigma'$$ for the public key $$X$$ and message $$M$$, where both signatures $$(r, s)$$ and $$(r, -s \\mod n)$$ are valid for $$X$$ and $$M$$, with $$s \\in \\mathbb{Z}_n$$.",
            "For a given $$\\sigma$$, we can find a random public key $$X'$$ that verifies for an arbitrary message $$M'$$ by tweaking the message."
          ]
        },
        {
          "title": "4.2: How the value of k affect signatures",
          "content": [
            "One message $$M$$ and one private key $$X$$ can have many different signatures $$\\sigma[]$$, as the choice of $$k$$ value affects the resulting signature. Implementations often use deterministic $$k$$ values based on the message and the secret key."
          ]
        },
        "Preventing these types of attacks can be acheived by storing the message hash after verifying it, and definitely not the signature. Using well-vetted libraries that confrom to ecosystem standards helps also."
      ]
    },
    {
      "title": "Section 5: Attacks on ECDSA Implementations",
      "content": [
        {
          "title": "5.1: Private Key Leakage Due To k Reuse",
          "content": [
            "As mentioned earlier, reusing the same nonce $$k$$ across different messages can lead to private key leakage. This is because the attacker can recover the private key $$x$$ from two different signatures with the same $$k$$ value. To avoid this issue, it's crucial to use a unique $$k$$ for each signature or to employ a deterministic $$k$$ generation method based on the message and private key."
          ]
        },
        {
          "title": "5.2: Insecure Random Number Generation",
          "content": [
            "The security of ECDSA relies heavily on the quality of the random numbers used, particularly when generating the nonce $$k$$. If an attacker can predict or influence the random number, or even a few bits of it, they may be able to compromise the security of the protocol."
          ]
        },
        {
          "title": "5.3: Incorrect Curve Parameter Selection",
          "content": [
            "Selecting inappropriate curve parameters can lead to vulnerabilities in the implementation. For example, if the order $$n$$ of the generator point $$G$$ is not prime, an attacker may exploit this by launching small-subgroup attacks. To avoid this, ensure that the chosen elliptic curve has a prime order $$n$$."
          ]
        },
        {
          "title": "5.4: Side-Channel Attacks And Other Leaked Data",
          "content": [
            "Side-channel attacks exploit information leaked through physical implementation rather than directly attacking the algorithm. Examples include timing attacks, power analysis, and electromagnetic radiation analysis. To protect against these attacks, use constant-time implementations and other countermeasures specific to the targeted side-channel."
          ]
        }
      ]
    }
  ]
}
